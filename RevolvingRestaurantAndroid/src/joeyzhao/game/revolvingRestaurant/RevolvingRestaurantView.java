package joeyzhao.game.revolvingRestaurant;

import java.util.Map;
import java.util.Set;


import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Paint.Style;
import android.view.MotionEvent;
import android.view.View;
import android.widget.TextView;

/**
 * This view extends the basic android.view.View to provide implementations for
 * drawing directly to the Canvas, and handling Touch events generated by the
 * user.
 * 
 * @author jatlas
 *
 */
public class RevolvingRestaurantView extends View implements StateChangeListener {
    // the current TicTacToeGame instance
    private RevolvingRestaurantGame game;
    
    // a message box that we can display status messages from the game in
    private TextView messageBox;
    
    // the width and height of the current game view
    private int width;
    private int height;
    
    private RRDatabase database;
    private RREndGameDialog dialog;
    // If we are using a 3D view to draw the pieces this will have a renderer,
    //  otherwise if we will draw a basic X/O 2D shape.
    /**I added the following**/
    private float unitW;//(width/(float)( game.getCurrentState().getRestaurant()[1].length)
    private float unitH;//height /(float)( game.getCurrentState().getRestaurant().length))
    
    private Shape3dRenderer renderer;

    public RevolvingRestaurantView(Context context, RevolvingRestaurantGame game, 
                           TextView messageBox,RRDatabase database) {
        super(context);
        this.game = game;
        this.messageBox = messageBox;
        this.database=database;
        this.dialog = new RREndGameDialog(this, database);
        
    }
    
    public RevolvingRestaurantGame getGame() {
        return game;
    }

    public void setGame(RevolvingRestaurantGame game) {
        this.game = game;
        if (renderer != null) {
            renderer.clearShapes();
        }
        
        game.addListener(this);
        
        // calling invalidate tells the Android platform that the view needs to be re-drawn
        invalidate();
    }

    
    public Shape3dRenderer getRenderer() {
        return renderer;
    }

    public void setRenderer(Shape3dRenderer renderer) {
        this.renderer = renderer;
    }

    @Override
    /**
     * Provides specific implementation for a RRView.  This view has 3 main components:
     *   - a grid
     *   - a set of pieces (could be 2d or 3d depending on if we have a renderer)
     *   - a message box
     */
    protected void onDraw(Canvas canvas) {

        updateMessageBox();
        super.onDraw(canvas);
        
        drawGrid(canvas);
        if (renderer == null) {
            drawPieces2d(canvas);
        }
        else {
            drawPieces3d();
        }
        
    }
    
    /**
     * The status text will display the current player
     * whose move it is during the game.  When the game has completed it will
     * show the winner or draw, and a short instruction on how to play again.
     */
    private void updateMessageBox() {
        // draw text for message
        String message;
   //     message="Print something!";
        if (!game.isEnded()) {
                message = "There are "+game.getCurrentState().getNumberOfDishes()+
                		" dishes on the table and "+game.getCurrentState().getAvailableDishes().size()+
                		" dishes coming! COINS:"+game.getCurrentState().getCoins();
         
        }
        else {
        Map<String, Integer> scoreMap=database.getScoreSummary(dialog.getLastInitials());
        String summary="Player "+dialog.getLastInitials()+" earned "+
    	scoreMap.get("last")+" coins in this game. Best personal records: " +scoreMap.get("top")+" Best of all time:"+database.getHighest();
       
            message = summary;
        }
        messageBox.setText(message);
    }
   
    /**
     * Draws a 5x5 grid with the middle square filled in.
     * 
     * @param canvas
     */
    private void drawGrid(Canvas canvas) {
        Paint gridPaint = new Paint();
        Paint crucial=new Paint();
        Paint crush=new Paint();
        crucial.setColor(Color.RED);
        crush.setColor(Color.LTGRAY);
        gridPaint.setColor(Color.WHITE);
        gridPaint.setStrokeWidth(4); // the "weight" of the lines
        gridPaint.setStyle(Style.FILL_AND_STROKE);
        float row=(float)( game.getCurrentState().getRestaurant().length);
        float col=(float)( game.getCurrentState().getRestaurant()[1].length);
        float scaleX = width / col;
        float scaleY = height / row;
        // draw horizontal lines for each row
        RevolvingRestaurantItems[][] board = game.getCurrentState().getRestaurant();
        for (int i = 0; i <= board.length; i++) {
            canvas.drawLine(0, i*scaleY, width, i*scaleY, gridPaint);
        }
        // draw vertical lines for each row
        for (int i = 0; i <= board.length; i++) {
            canvas.drawLine(i*scaleX, 0, i*scaleX, height, gridPaint);
        }
        
        for(int i=0;i<row;i++){
        	for(int j=0;j<col;j++){
        		if((i==2 && j!=0 &&j!=col-1 &&j!=col-2)||
        				(i==row-3&&j!=0&&j!=1&&j!=col-1&&j!=col-2)||
        				(j==2&&i!=0&&i!=1&&i!=row-1&&i!=row-2)||
        				(j==col-3&&i!=0&&i!=1&&i!=row-1&&i!=row-2)){
        			canvas.drawRect(scaleX*(j+1), scaleY*(i+1), scaleX*j, scaleY*i, gridPaint);
        		}
        	}
        }
        canvas.drawRect(scaleX*2, scaleY*3, scaleX, scaleY*2, crucial);
        canvas.drawRect(scaleX*3, scaleY*4, scaleX*2, scaleY*3, crucial);
        canvas.drawRect(scaleX*3, scaleY*3, scaleX*2, scaleY*2, crush);

        for(int k=0;k<board[0].length;k++){
        	if(board[0][k]==game.getCurrentState().getSelected()){
        		canvas.drawRect(scaleX*(k+1), scaleY, scaleX*k, 0, gridPaint);
        	}
        }
        //   
    }
    
    /**
     * Draws all of the pieces represented by the current game state.
     * Calls a separate method to draw each x and o by computing the correct upper left
     * corner x and y position and passing these into the other methods.
     * 
     * @param canvas
     */
    private void drawPieces2d(Canvas canvas) {
        // creating one Paint object for all x's
        Paint pieceXPaint = new Paint();
        pieceXPaint.setColor(Color.RED);
        pieceXPaint.setStrokeWidth(8);
        pieceXPaint.setStyle(Style.STROKE);
        
        // creating one Paint object for all o's
        Paint pieceOPaint = new Paint();
        pieceOPaint.setColor(Color.GREEN);
        pieceOPaint.setStrokeWidth(8);
        pieceOPaint.setStyle(Style.STROKE);
        
        RevolvingRestaurantItems[][] board = game.getCurrentState().getRestaurant();

        // loop through each position in the game state
        for (int row = 0; row < board.length; row++) {
            for (int col = 0; col < board[row].length; col++) {
                if (board[row][col] instanceof RevolvingRestaurantDish) {
                    drawDish(col*(unitW), row*(unitH), canvas, pieceXPaint);
                }
                else if (board[row][col] instanceof RevolvingRestaurantCustomer) {
                    drawCustomer(col*(unitW), row*(unitH), canvas, pieceOPaint);
                }
            }
        }
    }
    
    private void drawPieces3d() {
        // loop through each position in the game state
        // 
        // because 3d shapes are expensive to create, it is better
        //  to find out if the shape is new to our game (i.e. it was
        //  just placed).  If it is new, create a new Shape.  If it
        //  already exists do nothing (because in tic tac toe pieces
        //  do not move during the game other than animation).
        //
        // if your game has movement and you want to implement 3d graphics,
        // you will need to store an identifier in the renderer for your
        // game's Piece. This could be the Piece itself, but you may
        // want to consult the professor to make sure you map the game state
        // piece to the 3d shape properly.
    	
    	Set<Object> allShapes = getRenderer().getAllShapes();
        RevolvingRestaurantItems[][] board = game.getCurrentState().getRestaurant();
        float rowScale=2.0f/(float)( game.getCurrentState().getRestaurant().length);
        float colScale=2.0f/(float)( game.getCurrentState().getRestaurant()[1].length);
        for (int row = 0; row < board.length; row++) {
            for (int col = 0; col < board[row].length; col++) {
            	RevolvingRestaurantItems identifier = board[row][col]; // gives us a number between 0 and 24
                if (renderer.getShape(identifier) == null) {
                    Shape3d shape = null;
                    if (board[row][col] instanceof RevolvingRestaurantDish) {
                        shape = new Prism(0.1f/**change**/, new float[][]{{1, 0, 0, 1},{1, 0, 0, 1},{1, 0, 0, 1},{1, 0, 0, 1},{0, 0, 1, 1},{0, 0, 1, 1}});
                    }
                    else if (board[row][col] instanceof RevolvingRestaurantCustomer) {
                    	float red=0; float green=0; float blue=0; 
                    	if(board[row][col].getSymbol()=='A'){red=1f;}
                    	else if(board[row][col].getSymbol()=='B'){blue=1.5f;}
                    	else if(board[row][col].getSymbol()=='C'){green=1f; red=1f;}
                        shape = new Tetrahedron(0.1f/**change**/, new float[][]{{0, 0.5f, 0, 0.5f},{0, 0.5f, 0, 0.5f},{0, 0.5f, 0, 0.5f},{red, green,blue, 1}});
                    }
                    
                    if (shape != null) {
                        // need to reverse the position of the row since lower left is 0,0 in opengl
                        shape.setPosition(-1.0f+(0.5f+col)*colScale, 
                        		 1.0f-((row+0.5f)*rowScale), 0f);
                        renderer.addShape(identifier, shape);
                    }
                }
                else {
                	Shape3d shape = renderer.getShape(identifier);
                    // need to reverse the position of the row since lower left is 0,0 in opengl
                	shape.setPosition(-1.0f+(0.5f+col)*colScale, 
                   		 1.0f-((row+0.5f)*rowScale), 0f);
                	
                	allShapes.remove(identifier);
                }
            }
        }
        
        for (Object noLongerThere : allShapes) {
        	getRenderer().removeShape(noLongerThere);
        }
    }
    
   
    private void drawCustomer(float posx, float posy, Canvas canvas, Paint paint) {
        float xheight = (height / (float)( game.getCurrentState().getRestaurant().length)) - 10; // 5 pixel buffer
        float xwidth = (width / (float)( game.getCurrentState().getRestaurant()[1].length)) - 10;
        
        canvas.drawLine(posx + 5, posy + 5, posx + 5 + xwidth, posy + 5 + xheight, paint);
        canvas.drawLine(posx + 5 + xwidth, posy + 5, posx + 5, posy + 5 + xheight, paint);
    }

    
    private void drawDish(float posx, float posy, Canvas canvas, Paint paint) {
        float radius = Math.min((height/10.0f-5), 
        		(width/10.0f-5)); // 5 pixel buffer
        
        canvas.drawCircle(posx + (width/(float)( game.getCurrentState().getRestaurant()[1].length)), 
        		posy + (height/(float)( game.getCurrentState().getRestaurant().length)), radius, paint);
        
    }
    
    /**
     * This method is called by the Android platform when the app window size changes.
     * We store the initial setting of these so that we can compute the exact locations
     * to draw the components of our View.
     */
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);

        width = w;
        height = h;
        
        unitW=(width/(float)( game.getCurrentState().getRestaurant()[1].length));
        unitH=(height /(float)( game.getCurrentState().getRestaurant().length));
    }

    @Override
    /**
     * This method is called by the Android platform when the user generates any kind
     * of MotionEvent with the touch screen.  TicTacToe handles only ACTION_UP events (i.e.
     * the user "tapped" the screen at a location).
     */
    public boolean onTouchEvent(MotionEvent event) {
    	int action = event.getAction();

    	if (action == MotionEvent.ACTION_DOWN) {
    		return true;
    	} 
    	else if (action == MotionEvent.ACTION_UP) {
    		// two options:
    		//  1. Game has not ended. The location x,y is translated to a specific row,col.
    		//     We then check if it is a human's turn.  If so, we tell the human player
    		//     about the selection.
    		//  2. Game has ended. The user wants to play again, so we restart the game.
    		if (!game.isEnded()) {            
    			RevolvingRestaurantHumanPlayer player = game.getHumanPlayer();
    			float x = event.getX();
    			float y = event.getY();

    			float squareHeight = unitH;
    			float squareWidth = unitW;//(width /(float)(game.getCurrentState().getRestaurant()[1].length));

    			int row = (int)(y/squareHeight);
    			int col = (int)(x/squareWidth);
    			if (row > 10) {
    				row = 10;
    			}
    			else if (row < 0) {
    				row = 0;
    			}
    			if (col > 10) {
    				col = 10;
    			}
    			else if (col < 0) {
    				col = 0;
    			}


    			player.handleSquareSelection(row, col);
    			game.update();
    		}

    		else {
    			
    			// restart game
    			/**I don't know what to do here. Following is prof's code:**/
    			// game.reset();
    			//setGame(game);
    		}
    		if(game.isEnded()){
    			dialog.insertGameRecord(game);
    		}

    		

    		// forces the Android platform to re-draw the view.  Since user input changes
    		// the current game state, we need to force a re-draw.
    		invalidate();
    	}
    	return true;
    }

	@Override
	public void onStateChange(RevolvingRestaurantState state) {
		// TODO Auto-generated method stub
		invalidate();
	}
    
    
}
